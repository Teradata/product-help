<html><head></head><body><div class="nested0" aria-labelledby="ariaid-title1" topicindex="1" topicid="adn1507820123076" id="adn1507820123076"><h1 class="title topictitle1" id="ariaid-title1">XMLParser (ML Engine)</h1><div class="body conbody">
<p class="p">The XMLParser function takes XML documents and outputs their element
			names, attribute values, and text in a relational table, which you can search with SQL
			queries.</p>
<p class="p">XML data is semistructured and hierarchical, unlike the data in relational database tables. Therefore, you cannot search XML data with SQL queries unless you first <dfn class="term">relationalize</dfn> the XML data (that is, put it in a relational database table).</p>
<p class="p">Not all XML data can be relationalized; therefore, the XMLParser function constrains the relationships in the extracted data to grandparent/parent/child, parent/child, ancestor, and sibling relationships. The function lets you specify these constraints and the output table schema.</p></div><div class="topic reference nested1" aria-labelledby="ariaid-title2" topicindex="2" topicid="qsn1507820173806" xml:lang="en-us" lang="en-us" id="qsn1507820173806">
<h2 class="title topictitle2" id="ariaid-title2">XMLParser Syntax</h2><div class="body refbody"><div class="section" id="qsn1507820173806__section_N1000E_N1000C_N10001">
<h3 class="title sectiontitle">Version 2.3</h3><pre class="pre codeblock" xml:space="preserve"><code>SELECT * FROM XMLParser (
  <span>ON { <var class="keyword varname">table</var> | <var class="keyword varname">view</var> | (<var class="keyword varname">query</var>) }</span>
  USING
  TextColumn ('<var class="keyword varname">text_column</var>')
  Nodes ('<var class="keyword varname">node_pair_string</var> [,...]')
  [ Sibling ('<var class="keyword varname">sibling_node_string</var> [,...]') ]
  [ Delimiter ('<var class="keyword varname">delimiter</var>') ]
  [ SiblingDelimiter ('<var class="keyword varname">sibling_delimiter</var>') ]
  [ MaxItemNum (<var class="keyword varname">max_item_number</var>) ]
  [ Ancestor ('<var class="keyword varname">nodes_path</var>' [,...]) ]
  [ OutputColumnNodeID ('<var class="keyword varname">output_column_node</var>') ]
  [ OutputColumnParentNodeName ('<var class="keyword varname">output_column_parent_node</var>') ]
  [ OutputColumnGrandparentNodeName ('<var class="keyword varname">output_column_grandparent_node</var>') ]
  [ ErrorHandler ('<span><b>{'true'|'t'|'yes'|'y'|'1'|'false'|'f'|'no'|'n'|'0'}</b></span>[; [<var class="keyword varname">output_column</var>:] <var class="keyword varname">column</var>[,...]]') ]
  <code class="ph codeph">[ Accumulate ({ '<var class="keyword varname">accumulate_column</var>' | <var class="keyword varname">accumulate_column_range</var> }[,...]) ]</code>
) AS <var class="keyword varname">alias</var>;</code></pre></div></div><div class="related-links"><div class="linklistheader"><p></p><b>Related Information</b></div>
<ul class="linklist linklist relinfo"><div class="linklistmember"><a href="ndv1557782188375.md">Column Specification Syntax Elements</a></div></ul></div></div><div class="topic reference nested1" aria-labelledby="ariaid-title3" topicindex="3" topicid="yjf1507820178197" xml:lang="en-us" lang="en-us" id="yjf1507820178197">
<h2 class="title topictitle2" id="ariaid-title3">XMLParser Syntax Elements</h2><div class="body refbody"><div class="section" id="yjf1507820178197__section_N10011_N1000E_N10001"><dl class="dl parml"><dt class="dt pt dlterm">TextColumn</dt><dd class="dd pd">Specify the name of the input table column that contains the XML documents. The function skips malformed XML documents.</dd><dt class="dt pt dlterm">Nodes</dt><dd class="dd pd">Specify the node-pair strings from which the function extracts data. This is the simplest syntax for <var class="keyword varname">node_pair_string</var>:<pre class="pre codeblock" xml:space="preserve"><code>[<var class="keyword varname">grandparent</var>/]<var class="keyword varname">parent</var>/<var class="keyword varname">child</var>[,...]</code></pre>
<p class="p">where <var class="keyword varname">grandparent</var>, <var class="keyword varname">parent</var>, and <var class="keyword varname">child</var> are node names.</p>
<p class="p">For each <var class="keyword varname">grandparent</var>, <var class="keyword varname">parent</var>, and <var class="keyword varname">child</var>, you can specify one or more attributes to extract:</p><pre class="pre codeblock" xml:space="preserve"><code>{<var class="keyword varname">grandparent</var>|<var class="keyword varname">parent</var>|<var class="keyword varname">child</var>}[:<var class="keyword varname">attribute</var>[,...]]</code></pre>
<p class="p">For each <var class="keyword varname">node_pair_string</var>, the function creates a row in the output table and adds a column for each specified attribute.</p><div class="note note" id="yjf1507820178197__note_N10099_N1004E_N10042_N10030_N10011_N1000E_N1000C_N10001"><span><b>Note</b></span><div class="notebody">Node and attribute names are case-sensitive.</div></div>
<p class="p">A <var class="keyword varname">grandparent</var> or <var class="keyword varname">parent</var> without attributes can contain wildcards. The wildcards can follow the rules of either the SQL LIKE statement or the Java regular expression.</p><div class="p">The SQL LIKE statement syntax is <code class="ph codeph">'like(<var class="keyword varname">expression</var>)'</code>, where expression can include these wildcards:
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="yjf1507820178197__table_e5b_rzr_w1b" class="table" frame="border" border="1" rules="all"><div class="caption"></div><colgroup span="1"><col style="width:33.33333333333333%" span="1"></col><col style="width:66.66666666666666%" span="1"></col></colgroup><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:top;" id="d335987e253" rowspan="1" colspan="1">Wildcard Character</th><th class="entry cellrowborder" style="vertical-align:top;" id="d335987e255" rowspan="1" colspan="1">Meaning</th></tr></thead><tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:top;" headers="d335987e253" rowspan="1" colspan="1">Percent (%)</td><td class="entry cellrowborder" style="vertical-align:top;" headers="d335987e255" rowspan="1" colspan="1">Matches any sequence of zero or more characters.</td></tr><tr class="row"><td class="entry cellrowborder" style="vertical-align:top;" headers="d335987e253" rowspan="1" colspan="1">Underscore (_)</td><td class="entry cellrowborder" style="vertical-align:top;" headers="d335987e255" rowspan="1" colspan="1">Matches any single character.</td></tr><tr class="row"><td class="entry cellrowborder" style="vertical-align:top;" headers="d335987e253" rowspan="1" colspan="1">Backslash (\)</td><td class="entry cellrowborder" style="vertical-align:top;" headers="d335987e255" rowspan="1" colspan="1">Makes the wildcard character that follows an ordinary character.</td></tr></tbody></table></div></div>
<p class="p">For example, <code class="ph codeph">'like(%a_c\_)/d'</code> matches the XML fragment <code class="ph codeph"><123abc_><d><var class="keyword varname">text</var></d></123abc_></code>.</p>
<p class="p">The Java Regular Expression syntax is <code class="ph codeph">'regex(</code><var class="keyword varname">expression</var><code class="ph codeph">)'</code>, where expression follows the rules for a Java regular expression.</p>
<p class="p">If no <var class="keyword varname">node_pair_string</var> contains a parent node, or no <var class="keyword varname">node_pair_string</var> contains a grandparent node, the function outputs nothing. If no <var class="keyword varname">node_pair_string</var> contains a child node, the function outputs NULL child node values. If the syntax element specifies no attributes, the function outputs NULL attribute values.</p></dd><dt class="dt pt dlterm">Sibling</dt><dd class="dd pd">[Optional] Specify the sibling nodes of one parent node specified in the Nodes syntax element. This is the syntax for <var class="keyword varname">sibling_node_string</var>:<pre class="pre codeblock" xml:space="preserve"><code><var class="keyword varname">sibling_node_name</var>[:<var class="keyword varname">attribute</var>[,...]]</code></pre>
<p class="p">The function includes the values from the sibling nodes in every output row and adds a column to the output table for every sibling node and every specified attribute.</p>
<p class="p">If no <var class="keyword varname">sibling_node_string</var> contains a sibling node, the function outputs NULL sibling node values. If the syntax element specifies no attributes, the function outputs NULL attribute values.</p></dd><dt class="dt pt dlterm">Delimiter</dt><dd class="dd pd">[Optional] Specify the delimiter that separates multiple child node values in the output.</dd><dd class="dd pd ddexpand">Default: ',' (comma)</dd><dt class="dt pt dlterm">SiblingDelimiter</dt><dd class="dd pd">[Optional] Specify the delimiter that separates multiple sibling node values in the output.</dd><dd class="dd pd ddexpand">Default: ',' (comma)</dd><dt class="dt pt dlterm">MaxItemNum</dt><dd class="dd pd">[Optional] Specify the maximum number of sibling nodes with the same name to return. This value must be a positive integer.</dd><dd class="dd pd ddexpand">Default: 10</dd><dt class="dt pt dlterm">Ancestor</dt><dd class="dd pd">[Optional] Specify the ancestor paths for all parent nodes specified in the Nodes syntax element. This is the simplest syntax for <var class="keyword varname">nodes_path</var>:<pre class="pre codeblock" xml:space="preserve"><code><var class="keyword varname">node</var>[/<var class="keyword varname">node</var>]...</code></pre>
<p class="p">For each <var class="keyword varname">node</var>, you can specify one or more attributes:</p><pre class="pre codeblock" xml:space="preserve"><code><var class="keyword varname">node</var>[:<var class="keyword varname">attribute</var>[,...]]</code></pre>
<p class="p">A <var class="keyword varname">node</var> without attributes can contain wildcards. The wildcards can follow the rules of either the SQL LIKE statement or the Java regular expression. For details, see the description of the Node syntax element.</p>
<p class="p">If you specify multiple ancestor paths, the function parses each XML document to get results for each ancestor path. If different ancestor paths contain duplicate node names, as in the following example, the result can be ambiguous:</p><pre class="pre codeblock" xml:space="preserve"><code>SELECT * FROM xmlparser (
  ON xml_inputstext_column ('xml')
  Nodes ('parent1/child1')
  Ancestor ('A/B:attr/C:attr','A/C:attr/B:attr')
);</code></pre></dd><dd class="dd pd ddexpand">If different ancestor paths contain duplicate node names, the function does not check for duplicate node names in the ancestor paths when constructing the output. Instead, the function maintains a list of column names for all ancestor paths in the output schema. For each result, the function fills the values of its ancestor path in the list and creates the output for the ancestor part.</dd><dd class="dd pd ddexpand">If no <var class="keyword varname">nodes_path</var> is an ancestor path, the function outputs nothing. If the syntax element specifies no attributes, the function outputs NULL attribute values.</dd><dd class="dd pd ddexpand">Default: Root of the XML document</dd><dt class="dt pt dlterm">OutputColumnNodeID</dt><dd class="dd pd">[Optional] Specify the name of the output table column where the function stores the IDs of the extracted nodes.</dd><dd class="dd pd ddexpand">Default: 'out_nodeid'</dd><dt class="dt pt dlterm">OutputColumnParentNodeName</dt><dd class="dd pd">[Optional] Specify the name of the output table column where the function stores the names of the extracted parent nodes.</dd><dd class="dd pd ddexpand">Default: 'out_parent_node'</dd><dt class="dt pt dlterm">OutputColumn GrandparentNodeName</dt><dd class="dd pd">[Optional] Specify the name of the output table column where the function stores the tag names of the extracted grandparent nodes.</dd><dd class="dd pd ddexpand">Default: 'out_grandparent_node'</dd><dt class="dt pt dlterm">ErrorHandler</dt><dd class="dd pd">[Optional] Specify whether the function handles errors that occur when parsing an XML document.</dd><dd class="dd pd ddexpand">If you specify 'true':
<ul class="ul" id="yjf1507820178197__ul_ff3_fmy_kx">
<li class="li">If an error occurs while parsing a row, the function skips that row. When the function completes the parsing, it outputs only the nodes that were error-free.</li>
<li class="li">You can tell the function to output an additional column named <var class="keyword varname">output_column</var> and populate it with the values of the specified columns. In the output column, the values of the specified columns are separated with semicolons.
<p class="p">For example, the following syntax element adds the column error_info to the output table and populates it with the values of input columns col1 and col2 (with a semicolon after each value):</p><pre class="pre codeblock" xml:space="preserve"><code>ErrorHandler('true;error_info:col1,col2')</code></pre></li></ul></dd><dd class="dd pd ddexpand">Default: 'false' (The function aborts and throws an exception. The <var class="keyword varname">output_column</var> is ErrorHandler.)</dd><dt class="dt pt dlterm">Accumulate</dt><dd class="dd pd">[Optional] Specify the names of input column names to copy to the output table. No <var class="keyword varname">accumulate_column</var> can be specified by the syntax element OutputColumnNodeID, OutputColumnParentNodeName, or OutputColumnGrandparentNodeName.</dd><dd class="dd pd ddexpand">Default: All input columns</dd></dl></div></div></div><div class="topic reference nested1" aria-labelledby="ariaid-title4" topicindex="4" topicid="ubk1507820181903" xml:lang="en-us" lang="en-us" id="ubk1507820181903">
<h2 class="title topictitle2" id="ariaid-title4">XMLParser Input</h2><div class="body refbody"><div class="section" id="ubk1507820181903__section_rwz_vjn_zcb">
<h3 class="title sectiontitle">Input Table Schema</h3><div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="ubk1507820181903__table_N1000E_N1000C_N10001" class="table" frame="border" border="1" rules="all"><div class="caption"></div><colgroup span="1"><col style="width:21.428571428571427%" span="1"></col><col style="width:14.285714285714285%" span="1"></col><col style="width:64.28571428571429%" span="1"></col></colgroup><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry nocellnorowborder" style="vertical-align:top;" id="d335987e471" rowspan="1" colspan="1">Column</th><th class="entry nocellnorowborder" style="vertical-align:top;" id="d335987e473" rowspan="1" colspan="1">Data Type</th><th class="entry cell-norowborder" style="vertical-align:top;" id="d335987e475" rowspan="1" colspan="1">Description</th></tr></thead><tbody class="tbody"><tr class="row"><td class="entry nocellnorowborder" style="vertical-align:top;" headers="d335987e471" rowspan="1" colspan="1"><var class="keyword varname">text_column</var></td><td class="entry nocellnorowborder" style="vertical-align:top;" headers="d335987e473" rowspan="1" colspan="1">VARCHAR</td><td class="entry cell-norowborder" style="vertical-align:top;" headers="d335987e475" rowspan="1" colspan="1">XML document to parse. Function skips malformed XML documents.</td></tr><tr class="row"><td class="entry row-nocellborder" style="vertical-align:top;" headers="d335987e471" rowspan="1" colspan="1"><var class="keyword varname">accumulate_column</var></td><td class="entry row-nocellborder" style="vertical-align:top;" headers="d335987e473" rowspan="1" colspan="1">Any</td><td class="entry cellrowborder" style="vertical-align:top;" headers="d335987e475" rowspan="1" colspan="1">[Column appears once for each specified <var class="keyword varname">accumulate_column</var>.] <span>Column to copy to output table.</span></td></tr></tbody></table></div></div></div></div><div class="topic reference nested1" aria-labelledby="ariaid-title5" topicindex="5" topicid="wse1507820186324" xml:lang="en-us" lang="en-us" id="wse1507820186324">
<h2 class="title topictitle2" id="ariaid-title5">XMLParser Output</h2><div class="body refbody"><div class="section" id="wse1507820186324__section_N1000E_N1000C_N10001">
<p class="p">In these cases, the function outputs nothing:</p>
<ul class="ul" id="wse1507820186324__ul_ugf_1kn_zcb">
<li class="li">No <var class="keyword varname">nodes_path</var> specified by the Ancestor syntax element is an ancestor path.</li>
<li class="li">No <var class="keyword varname">node_pair_path</var> specified by the Nodes syntax element contains a parent node.</li>
<li class="li">No <var class="keyword varname">node_pair_path</var> specified by the Nodes syntax element contains a grandparent node.</li></ul>
<p class="p">Otherwise, the output table has a row for each node specified in the Nodes syntax element and for each descendant of each ancestor path specified in the Ancestor syntax element.</p></div><div class="section" id="wse1507820186324__section_vgf_1kn_zcb">
<h3 class="title sectiontitle">Output Table Schema</h3><div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="wse1507820186324__table_N1003A_N1000E_N1000C_N10001" class="table" width="100%" frame="border" border="1" rules="all"><div class="caption"></div><colgroup span="1"><col style="width:33.33333333333333%" span="1"></col><col style="width:16.666666666666664%" span="1"></col><col style="width:50%" span="1"></col></colgroup><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry nocellnorowborder" style="vertical-align:top;" id="d335987e539" rowspan="1" colspan="1">Column</th><th class="entry nocellnorowborder" style="vertical-align:top;" id="d335987e541" rowspan="1" colspan="1">Data Type</th><th class="entry cell-norowborder" style="vertical-align:top;" id="d335987e543" rowspan="1" colspan="1">Description</th></tr></thead><tbody class="tbody"><tr class="row"><td class="entry nocellnorowborder" style="vertical-align:top;" headers="d335987e539" rowspan="1" colspan="1"><var class="keyword varname">output_column_node</var></td><td class="entry nocellnorowborder" style="vertical-align:top;" headers="d335987e541" rowspan="1" colspan="1">INTEGER or VARCHAR</td><td class="entry cell-norowborder" style="vertical-align:top;" headers="d335987e543" rowspan="1" colspan="1">Identifier of extracted node.</td></tr><tr class="row"><td class="entry nocellnorowborder" style="vertical-align:top;" headers="d335987e539" rowspan="1" colspan="1"><var class="keyword varname">output_column_parent_node</var></td><td class="entry nocellnorowborder" style="vertical-align:top;" headers="d335987e541" rowspan="1" colspan="1">VARCHAR</td><td class="entry cell-norowborder" style="vertical-align:top;" headers="d335987e543" rowspan="1" colspan="1">Name of extracted parent node.</td></tr><tr class="row"><td class="entry nocellnorowborder" style="vertical-align:top;" headers="d335987e539" rowspan="1" colspan="1"><var class="keyword varname">parent_attribute</var></td><td class="entry nocellnorowborder" style="vertical-align:top;" headers="d335987e541" rowspan="1" colspan="1">VARCHAR</td><td class="entry cell-norowborder" style="vertical-align:top;" headers="d335987e543" rowspan="1" colspan="1">[Column appears once for each specified <var class="keyword varname">parent</var> attribute.] Attribute of extracted parent node if specified, otherwise NULL.</td></tr><tr class="row"><td class="entry nocellnorowborder" style="vertical-align:top;" headers="d335987e539" rowspan="1" colspan="1"><var class="keyword varname">output_column_grandparent_node</var></td><td class="entry nocellnorowborder" style="vertical-align:top;" headers="d335987e541" rowspan="1" colspan="1">VARCHAR</td><td class="entry cell-norowborder" style="vertical-align:top;" headers="d335987e543" rowspan="1" colspan="1">Name of extracted grandparent node.</td></tr><tr class="row"><td class="entry nocellnorowborder" style="vertical-align:top;" headers="d335987e539" rowspan="1" colspan="1"><var class="keyword varname">grandparent_attribute</var></td><td class="entry nocellnorowborder" style="vertical-align:top;" headers="d335987e541" rowspan="1" colspan="1">VARCHAR</td><td class="entry cell-norowborder" style="vertical-align:top;" headers="d335987e543" rowspan="1" colspan="1">[Column appears once for each specified <var class="keyword varname">grandparent</var> attribute.] Attribute of extracted grandparent node if specified, otherwise NULL.</td></tr><tr class="row"><td class="entry nocellnorowborder" style="vertical-align:top;" headers="d335987e539" rowspan="1" colspan="1"><var class="keyword varname">sibling_node_name</var></td><td class="entry nocellnorowborder" style="vertical-align:top;" headers="d335987e541" rowspan="1" colspan="1">VARCHAR</td><td class="entry cell-norowborder" style="vertical-align:top;" headers="d335987e543" rowspan="1" colspan="1">[Column appears once for each specified <var class="keyword varname">sibling_node_name</var>.] Name of extracted sibling node if specified, otherwise NULL.</td></tr><tr class="row"><td class="entry nocellnorowborder" style="vertical-align:top;" headers="d335987e539" rowspan="1" colspan="1"><var class="keyword varname">sibling_attribute</var></td><td class="entry nocellnorowborder" style="vertical-align:top;" headers="d335987e541" rowspan="1" colspan="1">VARCHAR</td><td class="entry cell-norowborder" style="vertical-align:top;" headers="d335987e543" rowspan="1" colspan="1">[Column appears once for each specified <var class="keyword varname">sibling_node_name</var> attribute.] Attribute of extracted sibling node if specified, otherwise NULL.</td></tr><tr class="row"><td class="entry nocellnorowborder" style="vertical-align:top;" headers="d335987e539" rowspan="1" colspan="1"><var class="keyword varname">child_node</var></td><td class="entry nocellnorowborder" style="vertical-align:top;" headers="d335987e541" rowspan="1" colspan="1">VARCHAR</td><td class="entry cell-norowborder" style="vertical-align:top;" headers="d335987e543" rowspan="1" colspan="1">[Column appears once for each specified <var class="keyword varname">child</var> attribute.] Name of extracted child node if specified, otherwise NULL.</td></tr><tr class="row"><td class="entry nocellnorowborder" style="vertical-align:top;" headers="d335987e539" rowspan="1" colspan="1"><var class="keyword varname">child_attribute</var></td><td class="entry nocellnorowborder" style="vertical-align:top;" headers="d335987e541" rowspan="1" colspan="1">VARCHAR</td><td class="entry cell-norowborder" style="vertical-align:top;" headers="d335987e543" rowspan="1" colspan="1">[Column appears once for each specified <var class="keyword varname">child</var> attribute.] Attribute of extracted child node if specified, otherwise NULL.</td></tr><tr class="row"><td class="entry nocellnorowborder" style="vertical-align:top;" headers="d335987e539" rowspan="1" colspan="1"><var class="keyword varname">ancestor_attribute</var></td><td class="entry nocellnorowborder" style="vertical-align:top;" headers="d335987e541" rowspan="1" colspan="1">VARCHAR</td><td class="entry cell-norowborder" style="vertical-align:top;" headers="d335987e543" rowspan="1" colspan="1">[Column appears once for each specified Ancestor <var class="keyword varname">node</var>.] Attribute of extracted Ancestor <var class="keyword varname">node</var> if specified, otherwise NULL.</td></tr><tr class="row"><td class="entry row-nocellborder" style="vertical-align:top;" headers="d335987e539" rowspan="1" colspan="1"><var class="keyword varname">accumulate_column</var></td><td class="entry row-nocellborder" style="vertical-align:top;" headers="d335987e541" rowspan="1" colspan="1"><span>Same as in Input table</span></td><td class="entry cellrowborder" style="vertical-align:top;" headers="d335987e543" rowspan="1" colspan="1">[Column appears once for each specified <var class="keyword varname">accumulate_column</var>.] <span>Column copied from input table.</span></td></tr></tbody></table></div></div></div></div><div class="topic concept nested1" aria-labelledby="ariaid-title6" topicindex="6" topicid="kto1510713398169" xml:lang="en-us" lang="en-us" id="kto1510713398169">
<h2 class="title topictitle2" id="ariaid-title6">XMLParser Examples</h2><div class="topic reference nested2" aria-labelledby="ariaid-title7" topicindex="7" topicid="goj1527097011608" xml:lang="en-us" lang="en-us" id="goj1527097011608">
<h3 class="title topictitle3" id="ariaid-title7">XMLParser Example: Sibling and Sibling_Delimiter</h3><div class="body refbody"><div class="section" id="goj1527097011608__section_N10011_N1000E_N10001">
<h4 class="title sectiontitle">Input</h4><div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="goj1527097011608__table_qds_zy4_xdb" class="table" frame="border" border="1" rules="all"><div class="caption"><span>xml_input1</span></div><colgroup span="1"><col style="width:50%" span="1"></col><col style="width:50%" span="1"></col></colgroup><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:top;" id="d335987e706" rowspan="1" colspan="1">xid</th><th class="entry cellrowborder" style="vertical-align:top;" id="d335987e708" rowspan="1" colspan="1">xmldocument</th></tr></thead><tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:top;" headers="d335987e706" rowspan="1" colspan="1">1</td><td class="entry cellrowborder" style="vertical-align:top;" headers="d335987e708" rowspan="1" colspan="1"><bookstore>
<p class="p">: <owner>Billy</owner></p>
<p class="p">: <book category="ASTRONOMY"></p>
<p class="p">: <title lang="en">Cosmos</title></p>
<p class="p">: <author>Carl Sagan</author></p>
<p class="p">: <author>Ann Druyan</author></p>
<p class="p">: <year edition="1">1980</year></p>
<p class="p">: <year edition="2">1981</year></p>
<p class="p">: <price></p>
<p class="p">: <member>49.99</member></p>
<p class="p">: <public>60.00</public></p>
<p class="p">: </price></p>
<p class="p">: <reference></p>
<p class="p">: <title>Comet</title></p>
<p class="p">: </reference></p>
<p class="p">: <position value="1" locate="east"></position></p>
<p class="p">: </book></p>
<p class="p">: <book category="CHILDREN"></p>
<p class="p">: <author>Judy Blume</author></p>
<p class="p">:</p>
<p class="p">: <price></p>
<p class="p">: <member>99.99</member></p>
<p class="p">: <public>108.00</public></p>
<p class="p">: </price></p>
<p class="p">: </book></p>
<p class="p">: </bookstore></p></td></tr><tr class="row"><td class="entry cellrowborder" style="vertical-align:top;" headers="d335987e706" rowspan="1" colspan="1">2</td><td class="entry cellrowborder" style="vertical-align:top;" headers="d335987e708" rowspan="1" colspan="1"><setTopRpt xsi:noNamespaceSchemaLocation="Set%20Top%2020Report%20.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchemainstance">
<p class="p">: <settopid type="string" length="5">ST789</settopid></p>
<p class="p">: <accountid type="string">8728</accountid></p>
<p class="p">: <zipcode type="string">94025</zipcode></p>
<p class="p">: <reportstamp type="dateTime">2009-10-03T12:52:06</reportstamp></p>
<p class="p">: <temperature></p>
<p class="p">: <read type="bigDecimal">46</read></p>
<p class="p">: </temperature></p>
<p class="p">: <storage></p>
<p class="p">: <used type="bigDecimal">98</used></p>
<p class="p">: <used type="bigDecimal">199</used></p>
<p class="p">: <used type="bigDecimal">247</used></p>
<p class="p">: <total type="bigDecimal">300</total></p>
<p class="p">: </storage></p>
<p class="p">: <feed></p>
<p class="p">: <feedstamp type="dateTime">2009-10-03T12:52:06</feedstamp></p>
<p class="p">: </feed></p>
<p class="p">: </setTopRpt></p></td></tr></tbody></table></div></div><div class="section" id="goj1527097011608__section_qjl_ky4_xdb">
<h4 class="title sectiontitle">SQL Call</h4><pre class="pre codeblock" xml:space="preserve"><code>SELECT * FROM XMLParser(
  ON xml_input1
  USING
  TextColumn('xmldocument')
  Nodes('price/member')
  Sibling('author','year','title')
  SiblingDelimiter(';')
  Accumulate('xid')
) AS dt ;</code></pre></div><div class="section" id="goj1527097011608__section_ihx_ky4_xdb">
<h4 class="title sectiontitle">Output</h4>
<p class="p">The parent node, price, has two child nodes, member and public. However, the Nodes syntax element specifies only member; therefore, only its value is output. Title, author, and year are siblings of price. The first document has multiple author and year siblings, so the values of those siblings are separated by the specified delimiter, semicolon (;).</p><pre class="pre screen" xml:space="preserve"> xid out_nodeid out_parent_node author                year      title  member 
 --- ---------- --------------- --------------------- --------- ------ ------ 
   1          1 price           Carl Sagan;Ann Druyan 1980;1981 Cosmos 49.99 
   1          2 price           Judy Blume                             99.99</pre>
<p class="p">Download a zip file of all examples and a SQL script file that creates their input tables from the attachment in the left sidebar.</p></div></div></div><div class="topic reference nested2" aria-labelledby="ariaid-title8" topicindex="8" topicid="wfz1527097104907" xml:lang="en-us" lang="en-us" id="wfz1527097104907">
<h3 class="title topictitle3" id="ariaid-title8">XMLParser Example: Ancestor</h3><div class="body refbody"><div class="section" id="wfz1527097104907__section_jqy_4y4_xdb">
<h4 class="title sectiontitle">Input</h4>
<ul class="ul" id="wfz1527097104907__ul_fmy_bpq_j2b">
<li class="li">xml_input1, as in <a href="rul1558453477627.md#goj1527097011608">XMLParser Example: Sibling and Sibling_Delimiter</a></li></ul></div><div class="section" id="wfz1527097104907__section_qjl_ky4_xdb">
<h4 class="title sectiontitle">SQL Call</h4><pre class="pre codeblock" xml:space="preserve"><code>SELECT * FROM XMLParser (
  ON xml_input1
  USING
  TextColumn ('xmldocument')
  Nodes ('temperature/read:type','storage/{used, total}')
  Sibling ('settopid:{type, length}','accountid')
  Ancestor ('setTopRpt')
  OutputColumnNodeID ('nid')
  MaxItemNum (1)
  Accumulate ('xid')
) AS dt;</code></pre></div><div class="section" id="wfz1527097104907__section_ihx_ky4_xdb">
<h4 class="title sectiontitle">Output</h4>
<p class="p">The output table has the node and sibling values of the specified ancestor, setTopRpt.</p><pre class="pre screen" xml:space="preserve"> xid nid out_parent_node settopid settopid_type settopid_length accountid read read_type  used total 
 --- --- --------------- -------- ------------- --------------- --------- ---- ---------- ---- ----- 
   2   1 temperature     ST789    string        5               8728      46   bigDecimal           
   2   2 storage         ST789    string        5               8728                      98   300</pre>
<p class="p">Download a zip file of all examples and a SQL script file that creates their input tables from the attachment in the left sidebar.</p></div></div></div><div class="topic reference nested2" aria-labelledby="ariaid-title9" topicindex="9" topicid="lil1527097168859" xml:lang="en-us" lang="en-us" id="lil1527097168859">
<h3 class="title topictitle3" id="ariaid-title9">XMLParser Example: Expressions in Nodes and Ancestor</h3><div class="body refbody"><div class="section" id="lil1527097168859__section_crp_sy4_xdb">
<h4 class="title sectiontitle">Input</h4><div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="lil1527097168859__table_thb_l1p_xdb" class="table" frame="border" border="1" rules="all"><div class="caption"><span>xml_inputs_fuzzy</span></div><colgroup span="1"><col style="width:50%" span="1"></col><col style="width:50%" span="1"></col></colgroup><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:top;" id="d335987e907" rowspan="1" colspan="1">xid</th><th class="entry cellrowborder" style="vertical-align:top;" id="d335987e909" rowspan="1" colspan="1">xmldocument</th></tr></thead><tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:top;" headers="d335987e907" rowspan="1" colspan="1">1</td><td class="entry cellrowborder" style="vertical-align:top;" headers="d335987e909" rowspan="1" colspan="1"><bookstore>
<p class="p">: <owner>Billy</owner><items></p>
<p class="p">: <bookitem category="ASTRONOMY"></p>
<p class="p">: <title lang="en">Cosmos</title></p>
<p class="p">: <author>Carl Sagan</author></p>
<p class="p">: <author>Ann Druyan</author></p>
<p class="p">: <year edition="1">1980</year></p>
<p class="p">: <price></p>
<p class="p">: <member>49.99</member></p>
<p class="p">: <public>60.00</public></p>
<p class="p">: </price></p>
<p class="p">: </bookitem></p>
<p class="p">: </items></p>
<p class="p">: </bookstore></p></td></tr><tr class="row"><td class="entry cellrowborder" style="vertical-align:top;" headers="d335987e907" rowspan="1" colspan="1">2</td><td class="entry cellrowborder" style="vertical-align:top;" headers="d335987e909" rowspan="1" colspan="1"><cdstore>
<p class="p">: <owner> Amy </owner></p>
<p class="p">: <items></p>
<p class="p">: <cditem category="pop"></p>
<p class="p">: <title lang="en">Breathe</title></p>
<p class="p">: <author>Yu Quan</author></p>
<p class="p">: <year>2003</year></p>
<p class="p">: <price></p>
<p class="p">: <member>29</member></p>
<p class="p">: <public>35</public></p>
<p class="p">: </price></p>
<p class="p">: <position value="1" locate="east"/></p>
<p class="p">: </cditem></p>
<p class="p">: </items></p>
<p class="p">: </cdstore></p></td></tr></tbody></table></div></div><div class="section" id="lil1527097168859__section_qjl_ky4_xdb">
<h4 class="title sectiontitle">SQL Call</h4>
<p class="p">The Ancestor syntax element specifies that any node whose value ends with 'store' is an ancestor. The Nodes syntax element specifies that the function is to output the owner of each store and the title, author, and year of each node that starts with a string of lowercase alphabetic characters and ends with 'item'.</p><pre class="pre codeblock" xml:space="preserve"><code>SELECT * FROM XMLParser (
  ON xml_inputs_fuzzy
  USING
  TextColumn ('xmlDocument')
  Nodes ('like(%store)/owner','regex([a-z]+item)/{title,author,year}')
  Ancestor ('like(%store)')
  Accumulate ('xid')
) AS dt ;</code></pre></div><div class="section" id="lil1527097168859__section_ihx_ky4_xdb">
<h4 class="title sectiontitle">Output</h4>
<p class="p">For bookstore and cdstore, the output table has the value of owner; for bookitem and cditem, the output table has the values of title, author, and year. Multiple values are separated by the default delimiter, comma (,).</p><pre class="pre screen" xml:space="preserve"> xid out_nodeid out_parent_node owner title   author                year 
 --- ---------- --------------- ----- ------- --------------------- ---- 
   1          1 bookstore       Billy                                   
   1          2 bookitem              Cosmos  Carl Sagan,Ann Druyan 1980
   2          1 cdstore          Amy                                    
   2          2 cditem                Breathe Yu Quan               2003</pre>
<p class="p">Download a zip file of all examples and a SQL script file that creates their input tables from the attachment in the left sidebar.</p></div></div></div><div class="topic reference nested2" aria-labelledby="ariaid-title10" topicindex="10" topicid="tjc1527097225363" xml:lang="en-us" lang="en-us" id="tjc1527097225363">
<h3 class="title topictitle3" id="ariaid-title10">XMLParser Example: ErrorHandler</h3><div class="body refbody"><div class="section" id="tjc1527097225363__section_kdz_vy4_xdb">
<h4 class="title sectiontitle">Input</h4>
<p class="p">The second XML document is missing the closing tag </bookstore>.</p><div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="tjc1527097225363__table_yth_y1p_xdb" class="table" frame="border" border="1" rules="all"><div class="caption"><span>xml_inputs_error</span></div><colgroup span="1"><col style="width:50%" span="1"></col><col style="width:50%" span="1"></col></colgroup><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:top;" id="d335987e1029" rowspan="1" colspan="1">xid</th><th class="entry cellrowborder" style="vertical-align:top;" id="d335987e1031" rowspan="1" colspan="1">xmldocument</th></tr></thead><tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:top;" headers="d335987e1029" rowspan="1" colspan="1">1</td><td class="entry cellrowborder" style="vertical-align:top;" headers="d335987e1031" rowspan="1" colspan="1"><bookstore owner="Judy">
<p class="p">: <owner>Billy</owner><items></p>
<p class="p">: <bookitem category="ASTRONOMY"></p>
<p class="p">: <title lang="en">Cosmos</title></p>
<p class="p">: <author>Carl Sagan</author></p>
<p class="p">: <author>Ann Druyan</author></p>
<p class="p">: <year edition="1">1980</year></p>
<p class="p">: <price></p>
<p class="p">: <member>49.99</member></p>
<p class="p">: <public>60.00</public></p>
<p class="p">: </price></p>
<p class="p">: </bookitem></p>
<p class="p">: </items></p>
<p class="p"></bookstore></p></td></tr><tr class="row"><td class="entry cellrowborder" style="vertical-align:top;" headers="d335987e1029" rowspan="1" colspan="1">2</td><td class="entry cellrowborder" style="vertical-align:top;" headers="d335987e1031" rowspan="1" colspan="1"><bookstore></td></tr></tbody></table></div></div><div class="section" id="tjc1527097225363__section_qjl_ky4_xdb">
<h4 class="title sectiontitle">SQL Call</h4><pre class="pre codeblock" xml:space="preserve"><code>SELECT * FROM XMLParser (
  ON xml_inputs_error
  USING
  TextColumn ('xmldocument')
  Nodes ('bookstore/owner','bookitem/title','bookitem/author')
  ErrorHandler ('true;xmldocument')
  Accumulate ('xid')
) AS dt ;</code></pre></div><div class="section" id="tjc1527097225363__section_ihx_ky4_xdb">
<h4 class="title sectiontitle">Output</h4>
<p class="p">The output table has the column ERROR_HANDLER, which contains the value of the input column xmldocument followed by a semicolon.</p><pre class="pre screen" xml:space="preserve"> xid out_nodeid out_parent_node owner title  author                errorhandler 
 --- ---------- --------------- ----- ------ --------------------- ------------ 
   1          1 bookstore       Billy                              NULL        
   1          2 bookitem              Cosmos Carl Sagan,Ann Druyan NULL        
   2       NULL NULL            NULL  NULL   NULL                  <bookstore>;</pre>
<p class="p">Download a zip file of all examples and a SQL script file that creates their input tables from the attachment in the left sidebar.</p></div></div></div><div class="topic reference nested2" aria-labelledby="ariaid-title11" topicindex="11" topicid="zwm1507820241415" xml:lang="en-us" lang="en-us" id="zwm1507820241415">
<h3 class="title topictitle3" id="ariaid-title11">XMLParser Example: Grandparent, Parent, and Child Nodes</h3><div class="body refbody"><div class="section" id="zwm1507820241415__section_N10011_N1000E_N10001">
<p class="p">This example uses the Nodes and Ancestors syntax elements to show the hierarchy of grandparent, parent, and child nodes.</p></div><div class="section" id="zwm1507820241415__section_ytj_lx4_xdb">
<h4 class="title sectiontitle">Input</h4><div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="zwm1507820241415__table_x5p_px4_xdb" class="table" frame="border" border="1" rules="all"><div class="caption"><span>xml_input2</span></div><colgroup span="1"><col style="width:50%" span="1"></col><col style="width:50%" span="1"></col></colgroup><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:top;" id="d335987e1119" rowspan="1" colspan="1">xid</th><th class="entry cellrowborder" style="vertical-align:top;" id="d335987e1121" rowspan="1" colspan="1">xml</th></tr></thead><tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:top;" headers="d335987e1119" rowspan="1" colspan="1">1</td><td class="entry cellrowborder" style="vertical-align:top;" headers="d335987e1121" rowspan="1" colspan="1"><School name="UCBerkeley">
<p class="p">: <Dept ID="CS" name="Computer Science"></p>
<p class="p">: <Class A="sophomore" B="Senior"></p>
<p class="p">: <Year></p>
<p class="p">: <Student>Harry</Student></p>
<p class="p">: <Grade>A+</Grade></p>
<p class="p">: </Year></p>
<p class="p">: </Class></p>
<p class="p">: </Dept></p>
<p class="p">: </School></p></td></tr></tbody></table></div></div><div class="section" id="zwm1507820241415__section_zht_lx4_xdb">
<h4 class="title sectiontitle">SQL Call</h4><pre class="pre codeblock" xml:space="preserve"><code>SELECT * FROM XMLParser (
  ON xml_input2 
  USING
  TextColumn ('xml')
  Nodes ('Class:{A,B}/Year/Student','Year/Grade')
  Ancestor ('School/Dept')
  Accumulate ('xid')
) AS dt;</code></pre></div><div class="section" id="zwm1507820241415__section_ujf_mx4_xdb">
<h4 class="title sectiontitle">Output</h4><pre class="pre screen" xml:space="preserve"> xid out_nodeid out_grandparent_node out_parent_node class_a   class_b student grade 
 --- ---------- -------------------- --------------- --------- ------- ------- ----- 
   1          1 Class                Year            sophomore Senior  Harry   A+</pre>
<p class="p">Download a zip file of all examples and a SQL script file that creates their input tables from the attachment in the left sidebar.</p></div></div></div></div></div></body></html>
