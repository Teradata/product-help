<html><head></head><body><div class="nested0" aria-labelledby="ariaid-title1" topicindex="1" topicid="sze1507753766343" id="sze1507753766343"><h1 class="title topictitle1" id="ariaid-title1">Betweenness (ML Engine)</h1><div class="body conbody">
<p class="p">The Betweenness function returns the betweenness score, a centrality
			measurement, for every vertex (node) in the input graph.</p><div class="fig fignone" id="sze1507753766343__fig_lq5_ncj_pw"><div class="caption"></div><br clear="none"></br><img class="image" id="sze1507753766343__image_ukd_4cj_pw" src="bhg1466005804534.svg" alt="How Machine Learning Engine function Betweenness works"></img><br clear="none"></br></div></div><div class="topic reference nested1" aria-labelledby="ariaid-title2" topicindex="2" topicid="nxo1507753921815" xml:lang="en-us" lang="en-us" id="nxo1507753921815">
<h2 class="title topictitle2" id="ariaid-title2">Betweenness Syntax</h2><div class="body refbody"><div class="section" id="nxo1507753921815__section_N1000E_N1000C_N10001">
<h3 class="title sectiontitle">Version <span>1.4</span></h3><pre class="pre codeblock" xml:space="preserve"><code>SELECT * FROM Betweenness (
  ON <var class="keyword varname">vertices_table</var> AS Vertices PARTITION BY <var class="keyword varname">vertex_key_column</var> [,...] 
  ON <var class="keyword varname">edges_table</var> AS Edges PARTITION BY <var class="keyword varname">source_vertex_key_column</var> [,...] 
  [ ON <var class="keyword varname">sources_table</var> AS Sources PARTITION BY <var class="keyword varname">source_vertex_key_column</var> [,...] ]
  [ ON <var class="keyword varname">targets_table</var> AS Targets PARTITION BY <var class="keyword varname">target_vertex_key_column</var> [,...] ]
  USING
  TargetKey ('<var class="keyword varname">target_key_column</var>' [,...])
  [ Directed (<span><b>{'true'|'t'|'yes'|'y'|'1'|'false'|'f'|'no'|'n'|'0'}</b></span>) ]
  [ EdgeWeight (<var class="keyword varname">edge_weight_column</var>) ]
  [ MaxDistance (<var class="keyword varname">max_distance</var>) ]
  [ GroupSize (<var class="keyword varname">group_size</var>) ]
  [ SampleRate (<var class="keyword varname">sample_rate</var>) ]
  <code class="ph codeph">[ Accumulate ({ '<var class="keyword varname">accumulate_column</var>' | <var class="keyword varname">accumulate_column_range</var> }[,...]) ]</code>
) AS <var class="keyword varname">alias</var>;</code></pre></div></div></div><div class="topic reference nested1" aria-labelledby="ariaid-title3" topicindex="3" topicid="dor1507758783990" xml:lang="en-us" lang="en-us" id="dor1507758783990">
<h2 class="title topictitle2" id="ariaid-title3">Betweenness Syntax Elements</h2><div class="body refbody"><div class="section" id="dor1507758783990__section_N10011_N1000E_N10001"><dl class="dl parml"><dt class="dt pt dlterm">TargetKey</dt><dd class="dd pd">Specify the target key (the names of the Edges table columns that identify the target vertex). If you specify <var class="keyword varname">targets_table</var>, then the function uses only the vertices in <var class="keyword varname">targets_table</var> as targets (which must be a subset of those that this syntax element specifies).</dd><dt class="dt pt dlterm">Directed</dt><dd class="dd pd">[Optional] Specify whether the graph is directed.</dd><dd class="dd pd ddexpand">Default: 'true'</dd><dt class="dt pt dlterm">EdgeWeight</dt><dd class="dd pd">[Optional] Specify the name of the Edges table column that contains edge weights. The weights are positive values.</dd><dd class="dd pd ddexpand">Default behavior: The weight of each edge is 1 (that is, the graph is unweighted).</dd><dt class="dt pt dlterm">MaxDistance</dt><dd class="dd pd">[Optional] Specify the maximum distance (an integer) between the source and target vertices. A negative <var class="keyword varname">max_distance</var> specifies an infinite distance. If vertices are separated by more than <var class="keyword varname">max_distance</var>, the function does not output them.</dd><dd class="dd pd ddexpand">Default: 10</dd><dt class="dt pt dlterm">GroupSize</dt><dd class="dd pd">[Optional] Specify the number of source vertices that execute a SNSP algorithm in parallel. If <var class="keyword varname">group_size</var> exceeds the number of source vertices in each partition, <var class="keyword varname">s</var>, then <var class="keyword varname">s</var> is the group size.</dd><dd class="dd pd ddexpand">Default behavior: The function calculates the optimal group size based on various cluster and query characteristics.
<p class="p">Running a group of vertices on each vworker, in parallel, uses less memory than running all vertices on each vworker.</p></dd><dt class="dt pt dlterm">SampleRate</dt><dd class="dd pd">[Optional] Specify the sample rate (the percentage of source vertices to sample), a DOUBLE PRECISION value in the range (0.0, 1.0]. The number of source vertices that the function uses to create betweenness is approximately <var class="keyword varname">sample_rate</var>*<var class="keyword varname">n</var>, where <var class="keyword varname">n</var> is the number of vertices in the graph.</dd><dt class="dt pt dlterm">Accumulate</dt><dd class="dd pd">[Optional] Specify the names of the Vertices table columns to copy to the output table. These columns enable you to identify the different betweenness scores in the output table.</dd></dl></div></div></div></div></body></html>
