<div class="nested0" aria-labelledby="ariaid-title1" topicindex="1" topicid="aui1506614984669" id="aui1506614984669"><h1 class="title topictitle1" id="ariaid-title1">SeriesSplitter (ML Engine)</h1><div class="body conbody">
<p class="p">The SeriesSplitter function splits partitions into subpartitions (called <dfn class="term">splits</dfn>) to balance the partitions for time series manipulation. The function creates an additional column that contains split identifiers. Each row contains the identifier of the split to which the row belongs. Optionally, the function also copies a specified number of boundary rows to each split.</p></div><div class="topic reference nested1" aria-labelledby="ariaid-title2" topicindex="2" topicid="qcj1506616699719" xml:lang="en-us" lang="en-us" id="qcj1506616699719">
<h2 class="title topictitle2" id="ariaid-title2">SeriesSplitter Syntax</h2><div class="body refbody"><div class="section" id="qcj1506616699719__section_N100E1_N10022_N10001">
<h3 class="title sectiontitle">Version ?</h3><pre class="pre codeblock" xml:space="preserve"><code>SELECT * FROM SeriesSplitter (
  <span>ON { <var class="keyword varname">table</var> | <var class="keyword varname">view</var> | (<var class="keyword varname">query</var>) }</span> AS InputTable
  [ OUT TABLE OutputTable (<var class="keyword varname">output_table</var>) ]
  [ OUT TABLE StatsTable (<var class="keyword varname">stats_table</var>) ]
  USING
  PartitionByColumns ('<var class="keyword varname">partition_column</var>' [,...])
  [ DuplicateRowsCount (<var class="keyword varname">value</var> [,...]) ]
  [ OrderByColumns ('<var class="keyword varname">order_column</var>' [,...]) ]
  [ SplitCount (<var class="keyword varname">split_count</var>) ]
  [ RowsPerSplit (<var class="keyword varname">rows_per_split</var>) ]
  <code class="ph codeph">[ Accumulate ({ '<var class="keyword varname">accumulate_column</var>' | <var class="keyword varname">accumulate_column_range</var> }[,...]) ]</code>
  [ SplitIDColumn ('<var class="keyword varname">split_id_column</var>') ]
  [ ReturnStats (<span><b>{'true'|'t'|'yes'|'y'|'1'|'false'|'f'|'no'|'n'|'0'}</b></span>) ]
  [ ValuesBeforeFirst ('<var class="keyword varname">value</var>' [,...]) ]
  [ ValuesAfterLast (<var class="keyword varname">value</var> [,...]) ]
  [ DuplicateColumn ('<var class="keyword varname">duplicate_column</var>') ]
  [ PartialSplitID (<span><b>{'true'|'t'|'yes'|'y'|'1'|'false'|'f'|'no'|'n'|'0'}</b></span>) ]
) AS <var class="keyword varname">alias</var>;</code></pre></div></div><div class="related-links"><div class="linklistheader"><p></p><b>Related Information</b></div>
<ul class="linklist linklist relinfo"><div class="linklistmember"><a href="ndv1557782188375.md">Column Specification Syntax Elements</a></div></ul></div></div><div class="topic reference nested1" aria-labelledby="ariaid-title3" topicindex="3" topicid="pxh1506616826881" xml:lang="en-us" lang="en-us" id="pxh1506616826881">
<h2 class="title topictitle2" id="ariaid-title3">SeriesSplitter Syntax Elements</h2><div class="body refbody"><div class="section" id="pxh1506616826881__section_N10011_N1000E_N10001"><dl class="dl parml"><dt class="dt pt dlterm">OutputTable</dt><dd class="dd pd">[Optional] Specify the name for the function output table.</dd><dd class="dd pd ddexpand">Default: partitioned_output in the current schema</dd><dt class="dt pt dlterm">StatsTable</dt><dd class="dd pd">[Optional] Specify the name for the statistics table that the function outputs.</dd><dd class="dd pd ddexpand">Default: stats_output in the current schema</dd><dt class="dt pt dlterm">PartitionByColumns</dt><dd class="dd pd">Specify the partition columns of the InputTable. These columns determine the identity of a partition. For data type restrictions of these columns, see the Teradata Database documentation.</dd><dt class="dt pt dlterm">DuplicateRowsCount</dt><dd class="dd pd">[Optional] Specify the number of rows to duplicate across split boundaries. If you specify only <var class="keyword varname">value1</var>, the function duplicates <var class="keyword varname">value1</var> rows from the previous partition and <var class="keyword varname">value1</var> rows from the next partition. If you specify both <var class="keyword varname">value1</var> and <var class="keyword varname">value2</var>, the function duplicates <var class="keyword varname">value1</var> rows from the previous partition and <var class="keyword varname">value2</var> rows from the next partition. Each syntax element value must be nonnegative integer less than or equal to 1000.</dd><dd class="dd pd ddexpand">Default: One row from the previous partition and one row from the next partition</dd><dt class="dt pt dlterm">OrderByColumns</dt><dd class="dd pd">[Optional] Specify the order columns of the InputTable. These columns establish the order of the rows and splits. Without this syntax element, the function can split the rows in any order.</dd><dt class="dt pt dlterm">SplitCount</dt><dd class="dd pd">[Optional] If the InputTable has multiple partitions, you cannot specify SplitCount. Instead, specify RowsPerSplit. Specify the desired number of splits in a partition of the OutputTable.</dd><dd class="dd pd ddexpand">The value of <var class="keyword varname">split_count</var> must be a positive BIGINT, and its upper bound is the number of rows in the partition. Base the value of <var class="keyword varname">split_count</var> on the desired amount of parallelism. For example, for a cluster with 10 vworkers, make <var class="keyword varname">split_count</var> a multiple of 10.</dd><dd class="dd pd ddexpand">If the number of rows in the InputTable (<var class="keyword varname">n</var>) is not exactly divisible by <var class="keyword varname">split_count</var>, the function estimates the number of splits in the partition, using this formula:
<p class="p"><code class="ph codeph">ceiling (</code><var class="keyword varname">n</var><code class="ph codeph"> / ceiling (</code><var class="keyword varname">n</var><code class="ph codeph"> / </code><var class="keyword varname">split_count</var><code class="ph codeph">))</code></p></dd><dd class="dd pd ddexpand">Default: 4</dd><dt class="dt pt dlterm">RowsPerSplit</dt><dd class="dd pd">[Optional] If the InputTable has multiple partitions, specify RowsPerSplit instead of SplitCount.
<p class="p">Specify the desired maximum number of rows in each split in the OutputTable. If the number of rows in the InputTable is not exactly divisible by <var class="keyword varname">rows_per_split</var>, the last split contains fewer than <var class="keyword varname">rows_per_split</var> rows, but no row contains more than <var class="keyword varname">rows_per_split</var> rows.</p>
<p class="p">The value of <var class="keyword varname">rows_per_split</var> must be a positive BIGINT.</p>
<p class="p">If the InputTable has multiple partitions and you do not specify RowsPerSplit, the function uses the value 1000.</p></dd><dt class="dt pt dlterm">Accumulate</dt><dd class="dd pd">[Optional] Specify the names of the InputTable columns (other than those specified by PartitionByColumns and OrderByColumns) to copy to the OutputTable.</dd><dd class="dd pd ddexpand">Default: Columns specified by PartitionByColumns and OrderByColumns</dd><dt class="dt pt dlterm">SplitIDColumn</dt><dd class="dd pd">[Optional] Specify the name for the OutputTable column to contain the split identifiers. If the OutputTable has another column named <var class="keyword varname">split_id_column</var>, the function returns an error. Therefore, if the OutputTable has a column named 'split_id' (specified by Accumulate, PartitionByColumns, or Order_By_Columns), you must use SplitIDColumn to specify a different <var class="keyword varname">split_id_column</var>.</dd><dd class="dd pd ddexpand">Default: 'split_id'</dd><dt class="dt pt dlterm"><span>ReturnStats</span></dt><dd class="dd pd">[Optional] Specify whether the function returns the data in the StatsTable in response to the command <code class="ph codeph">SELECT * FROM SeriesSplitter</code>. When this value is 'false', the function returns only the data in the OutputTable.</dd><dd class="dd pd ddexpand">Default: 'true'</dd><dt class="dt pt dlterm">ValuesBeforeFirst</dt><dd class="dd pd">[Optional] If DuplicateRowsCount is nonzero and OrderByColumns is specified, ValuesBeforeFirst specifies the values to store in the order columns that precede the first row of the first split in a partition as a result of duplicating rows across split boundaries.
<p class="p">If ValuesBeforeFirst specifies only one value and OrderByColumns specifies multiple order columns, the specified value is stored in every order column.</p>
<p class="p">If ValuesBeforeFirst specifies multiple values, it must specify a value for each order column. The value and the order column must have the same data type. For the data type VARCHAR, the values are case-insensitive.</p><div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="pxh1506616826881__table_jsf_5yf_bcb" class="table" frame="border" border="1" rules="all"><div class="caption"></div><colgroup span="1"><col style="width:50%" span="1"></col><col style="width:50%" span="1"></col></colgroup><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:top;" id="d27454e321" rowspan="1" colspan="1">Data Type</th><th class="entry cellrowborder" style="vertical-align:top;" id="d27454e323" rowspan="1" colspan="1">Default</th></tr></thead><tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:top;" headers="d27454e321" rowspan="1" colspan="1">Numeric</td><td class="entry cellrowborder" style="vertical-align:top;" headers="d27454e323" rowspan="1" colspan="1">-1</td></tr><tr class="row"><td class="entry cellrowborder" style="vertical-align:top;" headers="d27454e321" rowspan="1" colspan="1">CHARACTER(<var class="keyword varname">n</var>) or VARCHAR</td><td class="entry cellrowborder" style="vertical-align:top;" headers="d27454e323" rowspan="1" colspan="1">'-1'</td></tr><tr class="row"><td class="entry cellrowborder" style="vertical-align:top;" headers="d27454e321" rowspan="1" colspan="1">Date- or time-based</td><td class="entry cellrowborder" style="vertical-align:top;" headers="d27454e323" rowspan="1" colspan="1">1900-01-01 0:00:00</td></tr><tr class="row"><td class="entry cellrowborder" style="vertical-align:top;" headers="d27454e321" rowspan="1" colspan="1">CHARACTER</td><td class="entry cellrowborder" style="vertical-align:top;" headers="d27454e323" rowspan="1" colspan="1">'0'</td></tr></tbody></table></div></dd><dt class="dt pt dlterm">ValuesAfterLast</dt><dd class="dd pd">[Optional] If DuplicateRowsCount is nonzero and OrderByColumns is specified, ValuesAfterLast specifies the values to store in the order columns that follow the last row of the last split in a partition as a result of duplicating rows across split boundaries.</dd><dd class="dd pd ddexpand">If ValuesAfterLast specifies only one value and OrderByColumns specifies multiple order columns, the specified value is stored in every order column.</dd><dd class="dd pd ddexpand">If ValuesAfterLast specifies multiple values, it must specify a value for each order column. The value and the order column must have the same data type. For the data type VARCHAR, the values are case-insensitive.</dd><dd class="dd pd ddexpand">Default: NULL</dd><dt class="dt pt dlterm">DuplicateColumn</dt><dd class="dd pd">[Optional] Specify the name of the OutputTable column that indicates whether a row is duplicated from the neighboring split. If the row is duplicated, the column contains 1; otherwise it contains 0. If you omit this syntax element, the OutputTable does not have this column.</dd><dt class="dt pt dlterm">PartialSplitID</dt><dd class="dd pd">[Optional] Specify whether <var class="keyword varname">split_id_column</var> contains only the numeric split identifier.</dd><dd class="dd pd ddexpand">If the value is 'true', <var class="keyword varname">split_id_column</var> contains a numeric representation of the split identifier that is unique for each partition. To distribute the OutputTable by split, use a combination of all partition columns and <var class="keyword varname">split_id_column</var>.</dd><dd class="dd pd ddexpand">If the value is 'false', <var class="keyword varname">split_id_column</var> contains a string representation of the split that is unique across all partitions. The function creates the string representation by concatenating the partition columns with the order of the split inside the partition (the numeric representation). In the string representation, hyphens separate partition column names from each other and from the order. For example, 'pcol1-pcol2-3'.</dd><dd class="dd pd ddexpand">Default: 'false'</dd></dl></div></div></div></div>
