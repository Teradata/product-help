<div class="nested0" aria-labelledby="ariaid-title1" topicindex="1" topicid="obd1507836478638" id="obd1507836478638"><h1 class="title topictitle1" id="ariaid-title1">JSONParser (ML Engine)</h1><div class="body conbody">
<p class="p">The JSONParser function extracts the element name and text from a JSON string and outputs an equivalent relational table.</p></div><div class="topic reference nested1" aria-labelledby="ariaid-title2" topicindex="2" topicid="mxb1507836556226" xml:lang="en-us" lang="en-us" id="mxb1507836556226">
<h2 class="title topictitle2" id="ariaid-title2">JSONParser Syntax</h2><div class="body refbody"><div class="section" id="mxb1507836556226__section_N1000E_N1000C_N10001">
<h3 class="title sectiontitle">Version <span>1.12</span></h3><pre class="pre codeblock" xml:space="preserve"><code>SELECT * FROM JSONParser (
  <span>ON { <var class="keyword varname">table</var> | <var class="keyword varname">view</var> | (<var class="keyword varname">query</var>) }</span>
  USING
  TextColumn ('<var class="keyword varname">text_column</var>')
  Nodes ('<var class="keyword varname">parent_node</var>/<var class="keyword varname">child_node</var>' [,...])
  [ SearchPath ('<var class="keyword varname">node_name</var>/...') ]
  [ Delimiter ('<var class="keyword varname">delimiter</var>') ]
  [ MaxItemNum (<var class="keyword varname">max_item_number</var>) ]
  [ NodeIDOutputColumn ('<var class="keyword varname">node_id_output_column</var>') ]
  [ ParentNodeOutputColumn ('<var class="keyword varname">parent_node_output_column</var>') ]
  <code class="ph codeph">[ Accumulate ({ '<var class="keyword varname">accumulate_column</var>' | <var class="keyword varname">accumulate_column_range</var> }[,...]) ]</code>
  [ ErrorHandler ('<span><b>{'true'|'t'|'yes'|'y'|'1'|'false'|'f'|'no'|'n'|'0'}</b></span>
    [[; <var class="keyword varname">output_column</var> :] <var class="keyword varname">input_column</var> [,...]')]
  ]
) AS <var class="keyword varname">alias</var>;</code></pre></div></div><div class="related-links"><div class="linklistheader"><p></p><b>Related Information</b></div>
<ul class="linklist linklist relinfo"><div class="linklistmember"><a href="ndv1557782188375.md">Column Specification Syntax Elements</a></div></ul></div></div><div class="topic reference nested1" aria-labelledby="ariaid-title3" topicindex="3" topicid="ohl1507836559867" xml:lang="en-us" lang="en-us" id="ohl1507836559867">
<h2 class="title topictitle2" id="ariaid-title3">JSONParser Syntax Elements</h2><div class="body refbody"><div class="section" id="ohl1507836559867__section_N10011_N1000E_N10001"><dl class="dl parml"><dt class="dt pt dlterm">TextColumn</dt><dd class="dd pd">Specify the name of the input table column that contains the JSON string.</dd><dt class="dt pt dlterm">Nodes</dt><dd class="dd pd">Specify the parent/child pairs. All pairs must have the same format. You can specify a parent with multiple children with this syntax:<pre class="pre codeblock" xml:space="preserve"><code><var class="keyword varname">parent_node</var>/{<var class="keyword varname">child_node</var> [,…]}</code></pre></dd><dd class="dd pd ddexpand">JSON has two format types for arrays:
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="ohl1507836559867__table_qtx_15w_v1b" class="table" frame="border" border="1" rules="all"><div class="caption"></div><colgroup span="1"><col style="width:50%" span="1"></col><col style="width:50%" span="1"></col></colgroup><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:top;" id="d4811e178" rowspan="1" colspan="1">Array Format Type</th><th class="entry cellrowborder" style="vertical-align:top;" id="d4811e180" rowspan="1" colspan="1">Nodes Syntax Element</th></tr></thead><tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:top;" headers="d4811e178" rowspan="1" colspan="1">parent:[key:value,key:value]</td><td class="entry cellrowborder" style="vertical-align:top;" headers="d4811e180" rowspan="1" colspan="1">'parent/key'</td></tr><tr class="row"><td class="entry cellrowborder" style="vertical-align:top;" headers="d4811e178" rowspan="1" colspan="1">parent[value,value]</td><td class="entry cellrowborder" style="vertical-align:top;" headers="d4811e180" rowspan="1" colspan="1">'parent/parent'</td></tr></tbody></table></div></dd><dd class="dd pd ddexpand">Root sometimes has a key:value pair, as in <a href="iga1551388377508.md">JSONParser Example: Default Values</a>. To get the value of such a pair, use Nodes syntax element '/key'.</dd><dt class="dt pt dlterm">SearchPath</dt><dd class="dd pd">[Optional] Specify the path to find the direct value of the child. To reach the grandparent, include it in this path. When you include the path to the grandparent, you can output all siblings of the parent by including them in the Nodes syntax element. If anything from root is to be parsed, represent it as either '/' or an empty string.</dd><dd class="dd pd ddexpand">Default behavior: The function does not output the direct values of the children.</dd><dt class="dt pt dlterm">Delimiter</dt><dd class="dd pd">[Optional] Specify the delimiter that separates multiple children with the same name and the same parent node in the JSON String.</dd><dd class="dd pd ddexpand">The <var class="keyword varname">delimiter</var> cannot include '#'.</dd><dd class="dd pd ddexpand">Default: ',' (comma)</dd><dt class="dt pt dlterm">MaxItemNum</dt><dd class="dd pd">[Optional] Specify the maximum number of nodes with the same name to display in the output.</dd><dd class="dd pd ddexpand">Default: 10</dd><dt class="dt pt dlterm">NodeIDOutputColumn</dt><dd class="dd pd">[Optional] Specify the name of the column to use in the result schema to contain the identifier (from the input table) of the each node extracted.</dd><dd class="dd pd ddexpand">Default: 'out_nodeid'</dd><dt class="dt pt dlterm">ParentNodeOutputColumn</dt><dd class="dd pd">[Optional] Specify the name of column to use in the result schema to contain the tag name of the parent node extracted.</dd><dd class="dd pd ddexpand">Default: 'out_parent_node'</dd><dt class="dt pt dlterm">Accumulate</dt><dd class="dd pd">[Optional] Specify the names of the input table columns to copy to the output table.</dd><dt class="dt pt dlterm">ErrorHandler</dt><dd class="dd pd">[Optional] Specify whether the function continues processing when the input table has bad data (for example, invalid UTF-8 characters) and adds an error column to the output table.</dd><dd class="dd pd ddexpand">Default: 'false'. (The function aborts.)
<p class="p">The name of the error column is <var class="keyword varname">output_column</var>.</p>
<p class="p">Default: ERROR_HANDLER</p>
<p class="p">The error column contains the data from each specified <var class="keyword varname">input_column</var>, separated by semicolons. If you specify no <var class="keyword varname">input_column</var>, the error column is empty.</p></dd></dl></div></div></div></div>
