<div class="nested0" aria-labelledby="ariaid-title1" topicindex="1" topicid="adn1507820123076" id="adn1507820123076"><h1 class="title topictitle1" id="ariaid-title1">XMLParser (ML Engine)</h1><div class="body conbody">
<p class="p">The XMLParser function takes XML documents and outputs their element
			names, attribute values, and text in a relational table, which you can search with SQL
			queries.</p>
<p class="p">XML data is semistructured and hierarchical, unlike the data in relational database tables. Therefore, you cannot search XML data with SQL queries unless you first <dfn class="term">relationalize</dfn> the XML data (that is, put it in a relational database table).</p>
<p class="p">Not all XML data can be relationalized; therefore, the XMLParser function constrains the relationships in the extracted data to grandparent/parent/child, parent/child, ancestor, and sibling relationships. The function lets you specify these constraints and the output table schema.</p></div><div class="topic reference nested1" aria-labelledby="ariaid-title2" topicindex="2" topicid="qsn1507820173806" xml:lang="en-us" lang="en-us" id="qsn1507820173806">
<h2 class="title topictitle2" id="ariaid-title2">XMLParser Syntax</h2><div class="body refbody"><div class="section" id="qsn1507820173806__section_N1000E_N1000C_N10001">
<h3 class="title sectiontitle">Version 2.3</h3><pre class="pre codeblock" xml:space="preserve"><code>SELECT * FROM XMLParser (
  <span>ON { <var class="keyword varname">table</var> | <var class="keyword varname">view</var> | (<var class="keyword varname">query</var>) }</span>
  USING
  TextColumn ('<var class="keyword varname">text_column</var>')
  Nodes ('<var class="keyword varname">node_pair_string</var> [,...]')
  [ Sibling ('<var class="keyword varname">sibling_node_string</var> [,...]') ]
  [ Delimiter ('<var class="keyword varname">delimiter</var>') ]
  [ SiblingDelimiter ('<var class="keyword varname">sibling_delimiter</var>') ]
  [ MaxItemNum (<var class="keyword varname">max_item_number</var>) ]
  [ Ancestor ('<var class="keyword varname">nodes_path</var>' [,...]) ]
  [ OutputColumnNodeID ('<var class="keyword varname">output_column_node</var>') ]
  [ OutputColumnParentNodeName ('<var class="keyword varname">output_column_parent_node</var>') ]
  [ OutputColumnGrandparentNodeName ('<var class="keyword varname">output_column_grandparent_node</var>') ]
  [ ErrorHandler ('<span><b>{'true'|'t'|'yes'|'y'|'1'|'false'|'f'|'no'|'n'|'0'}</b></span>[; [<var class="keyword varname">output_column</var>:] <var class="keyword varname">column</var>[,...]]') ]
  <code class="ph codeph">[ Accumulate ({ '<var class="keyword varname">accumulate_column</var>' | <var class="keyword varname">accumulate_column_range</var> }[,...]) ]</code>
) AS <var class="keyword varname">alias</var>;</code></pre></div></div><div class="related-links"><div class="linklistheader"><p></p><b>Related Information</b></div>
<ul class="linklist linklist relinfo"><div class="linklistmember"><a href="ndv1557782188375.md">Column Specification Syntax Elements</a></div></ul></div></div><div class="topic reference nested1" aria-labelledby="ariaid-title3" topicindex="3" topicid="yjf1507820178197" xml:lang="en-us" lang="en-us" id="yjf1507820178197">
<h2 class="title topictitle2" id="ariaid-title3">XMLParser Syntax Elements</h2><div class="body refbody"><div class="section" id="yjf1507820178197__section_N10011_N1000E_N10001"><dl class="dl parml"><dt class="dt pt dlterm">TextColumn</dt><dd class="dd pd">Specify the name of the input table column that contains the XML documents. The function skips malformed XML documents.</dd><dt class="dt pt dlterm">Nodes</dt><dd class="dd pd">Specify the node-pair strings from which the function extracts data. This is the simplest syntax for <var class="keyword varname">node_pair_string</var>:<pre class="pre codeblock" xml:space="preserve"><code>[<var class="keyword varname">grandparent</var>/]<var class="keyword varname">parent</var>/<var class="keyword varname">child</var>[,...]</code></pre>
<p class="p">where <var class="keyword varname">grandparent</var>, <var class="keyword varname">parent</var>, and <var class="keyword varname">child</var> are node names.</p>
<p class="p">For each <var class="keyword varname">grandparent</var>, <var class="keyword varname">parent</var>, and <var class="keyword varname">child</var>, you can specify one or more attributes to extract:</p><pre class="pre codeblock" xml:space="preserve"><code>{<var class="keyword varname">grandparent</var>|<var class="keyword varname">parent</var>|<var class="keyword varname">child</var>}[:<var class="keyword varname">attribute</var>[,...]]</code></pre>
<p class="p">For each <var class="keyword varname">node_pair_string</var>, the function creates a row in the output table and adds a column for each specified attribute.</p><div class="note note" id="yjf1507820178197__note_N10099_N1004E_N10042_N10030_N10011_N1000E_N1000C_N10001"><span><b>Note</b></span><div class="notebody">Node and attribute names are case-sensitive.</div></div>
<p class="p">A <var class="keyword varname">grandparent</var> or <var class="keyword varname">parent</var> without attributes can contain wildcards. The wildcards can follow the rules of either the SQL LIKE statement or the Java regular expression.</p><div class="p">The SQL LIKE statement syntax is <code class="ph codeph">'like(<var class="keyword varname">expression</var>)'</code>, where expression can include these wildcards:
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="yjf1507820178197__table_e5b_rzr_w1b" class="table" frame="border" border="1" rules="all"><div class="caption"></div><colgroup span="1"><col style="width:33.33333333333333%" span="1"></col><col style="width:66.66666666666666%" span="1"></col></colgroup><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:top;" id="d61152e253" rowspan="1" colspan="1">Wildcard Character</th><th class="entry cellrowborder" style="vertical-align:top;" id="d61152e255" rowspan="1" colspan="1">Meaning</th></tr></thead><tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:top;" headers="d61152e253" rowspan="1" colspan="1">Percent (%)</td><td class="entry cellrowborder" style="vertical-align:top;" headers="d61152e255" rowspan="1" colspan="1">Matches any sequence of zero or more characters.</td></tr><tr class="row"><td class="entry cellrowborder" style="vertical-align:top;" headers="d61152e253" rowspan="1" colspan="1">Underscore (_)</td><td class="entry cellrowborder" style="vertical-align:top;" headers="d61152e255" rowspan="1" colspan="1">Matches any single character.</td></tr><tr class="row"><td class="entry cellrowborder" style="vertical-align:top;" headers="d61152e253" rowspan="1" colspan="1">Backslash (\)</td><td class="entry cellrowborder" style="vertical-align:top;" headers="d61152e255" rowspan="1" colspan="1">Makes the wildcard character that follows an ordinary character.</td></tr></tbody></table></div></div>
<p class="p">For example, <code class="ph codeph">'like(%a_c\_)/d'</code> matches the XML fragment <code class="ph codeph"><123abc_><d><var class="keyword varname">text</var></d></123abc_></code>.</p>
<p class="p">The Java Regular Expression syntax is <code class="ph codeph">'regex(</code><var class="keyword varname">expression</var><code class="ph codeph">)'</code>, where expression follows the rules for a Java regular expression.</p>
<p class="p">If no <var class="keyword varname">node_pair_string</var> contains a parent node, or no <var class="keyword varname">node_pair_string</var> contains a grandparent node, the function outputs nothing. If no <var class="keyword varname">node_pair_string</var> contains a child node, the function outputs NULL child node values. If the syntax element specifies no attributes, the function outputs NULL attribute values.</p></dd><dt class="dt pt dlterm">Sibling</dt><dd class="dd pd">[Optional] Specify the sibling nodes of one parent node specified in the Nodes syntax element. This is the syntax for <var class="keyword varname">sibling_node_string</var>:<pre class="pre codeblock" xml:space="preserve"><code><var class="keyword varname">sibling_node_name</var>[:<var class="keyword varname">attribute</var>[,...]]</code></pre>
<p class="p">The function includes the values from the sibling nodes in every output row and adds a column to the output table for every sibling node and every specified attribute.</p>
<p class="p">If no <var class="keyword varname">sibling_node_string</var> contains a sibling node, the function outputs NULL sibling node values. If the syntax element specifies no attributes, the function outputs NULL attribute values.</p></dd><dt class="dt pt dlterm">Delimiter</dt><dd class="dd pd">[Optional] Specify the delimiter that separates multiple child node values in the output.</dd><dd class="dd pd ddexpand">Default: ',' (comma)</dd><dt class="dt pt dlterm">SiblingDelimiter</dt><dd class="dd pd">[Optional] Specify the delimiter that separates multiple sibling node values in the output.</dd><dd class="dd pd ddexpand">Default: ',' (comma)</dd><dt class="dt pt dlterm">MaxItemNum</dt><dd class="dd pd">[Optional] Specify the maximum number of sibling nodes with the same name to return. This value must be a positive integer.</dd><dd class="dd pd ddexpand">Default: 10</dd><dt class="dt pt dlterm">Ancestor</dt><dd class="dd pd">[Optional] Specify the ancestor paths for all parent nodes specified in the Nodes syntax element. This is the simplest syntax for <var class="keyword varname">nodes_path</var>:<pre class="pre codeblock" xml:space="preserve"><code><var class="keyword varname">node</var>[/<var class="keyword varname">node</var>]...</code></pre>
<p class="p">For each <var class="keyword varname">node</var>, you can specify one or more attributes:</p><pre class="pre codeblock" xml:space="preserve"><code><var class="keyword varname">node</var>[:<var class="keyword varname">attribute</var>[,...]]</code></pre>
<p class="p">A <var class="keyword varname">node</var> without attributes can contain wildcards. The wildcards can follow the rules of either the SQL LIKE statement or the Java regular expression. For details, see the description of the Node syntax element.</p>
<p class="p">If you specify multiple ancestor paths, the function parses each XML document to get results for each ancestor path. If different ancestor paths contain duplicate node names, as in the following example, the result can be ambiguous:</p><pre class="pre codeblock" xml:space="preserve"><code>SELECT * FROM xmlparser (
  ON xml_inputstext_column ('xml')
  Nodes ('parent1/child1')
  Ancestor ('A/B:attr/C:attr','A/C:attr/B:attr')
);</code></pre></dd><dd class="dd pd ddexpand">If different ancestor paths contain duplicate node names, the function does not check for duplicate node names in the ancestor paths when constructing the output. Instead, the function maintains a list of column names for all ancestor paths in the output schema. For each result, the function fills the values of its ancestor path in the list and creates the output for the ancestor part.</dd><dd class="dd pd ddexpand">If no <var class="keyword varname">nodes_path</var> is an ancestor path, the function outputs nothing. If the syntax element specifies no attributes, the function outputs NULL attribute values.</dd><dd class="dd pd ddexpand">Default: Root of the XML document</dd><dt class="dt pt dlterm">OutputColumnNodeID</dt><dd class="dd pd">[Optional] Specify the name of the output table column where the function stores the IDs of the extracted nodes.</dd><dd class="dd pd ddexpand">Default: 'out_nodeid'</dd><dt class="dt pt dlterm">OutputColumnParentNodeName</dt><dd class="dd pd">[Optional] Specify the name of the output table column where the function stores the names of the extracted parent nodes.</dd><dd class="dd pd ddexpand">Default: 'out_parent_node'</dd><dt class="dt pt dlterm">OutputColumn GrandparentNodeName</dt><dd class="dd pd">[Optional] Specify the name of the output table column where the function stores the tag names of the extracted grandparent nodes.</dd><dd class="dd pd ddexpand">Default: 'out_grandparent_node'</dd><dt class="dt pt dlterm">ErrorHandler</dt><dd class="dd pd">[Optional] Specify whether the function handles errors that occur when parsing an XML document.</dd><dd class="dd pd ddexpand">If you specify 'true':
<ul class="ul" id="yjf1507820178197__ul_ff3_fmy_kx">
<li class="li">If an error occurs while parsing a row, the function skips that row. When the function completes the parsing, it outputs only the nodes that were error-free.</li>
<li class="li">You can tell the function to output an additional column named <var class="keyword varname">output_column</var> and populate it with the values of the specified columns. In the output column, the values of the specified columns are separated with semicolons.
<p class="p">For example, the following syntax element adds the column error_info to the output table and populates it with the values of input columns col1 and col2 (with a semicolon after each value):</p><pre class="pre codeblock" xml:space="preserve"><code>ErrorHandler('true;error_info:col1,col2')</code></pre></li></ul></dd><dd class="dd pd ddexpand">Default: 'false' (The function aborts and throws an exception. The <var class="keyword varname">output_column</var> is ErrorHandler.)</dd><dt class="dt pt dlterm">Accumulate</dt><dd class="dd pd">[Optional] Specify the names of input column names to copy to the output table. No <var class="keyword varname">accumulate_column</var> can be specified by the syntax element OutputColumnNodeID, OutputColumnParentNodeName, or OutputColumnGrandparentNodeName.</dd><dd class="dd pd ddexpand">Default: All input columns</dd></dl></div></div></div></div>
