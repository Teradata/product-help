ユーザー マッピングは、開始システムにログインしているユーザーがターゲット システム上の特定のユーザーとしてクエリーを実行できるようにします。多くの場合、ユーザー マッピングはオプションです。

HiveまたはSparkのターゲット データ ソースに認証設定が行われていない場合、クエリーの実行にあたりユーザー マッピングが必要です。クエリーを開始するユーザーが信頼されていないクラスタ上のターゲット システムに存在しない場合、クエリーは実行されません。

## 認証なし


たとえば、認証設定が行われていない状態で、ユーザー「Joe」が未認証のクラスタでTeradataからHiveへのリンクを使用してクエリーを実行したとします。すると既定では、Teradataはユーザー名「Joe」をすべて大文字に変換し、ユーザー「JOE」としてターゲット システムにクエリーを送信します。Hiveターゲット コネクタが保護されていない場合、このユース ケースでは次のような結果が考えられます。

|シナリオ|要件|
|---------|------------|
|ターゲット システムにユーザー「JOE」が存在しない|ターゲット システム上の既存のユーザー (「hive」など) でクエリーを実行する必要があります。このシナリオでは、Teradataシステム上の「JOE」をHiveシステム上のユーザー「hive」にマッピングする必要があります。|
|ユーザーがターゲット システムに「joe」として存在する|ユーザー マッピングが必要です。Teradataシステム上の「JOE」をターゲットのHiveシステム上の「joe」にマッピングします。|
|ターゲット上に「JOE」として存在する|このシナリオではユーザー マッピングの必要はありません。|

## 認証あり


HiveおよびSparkコネクタが **Kerberos** 認証方法を使用する場合、QueryGridエンドユーザーの偽装は単一のKerberosサービス アカウントで使用可能です。このシナリオではユーザー マッピングが必要です。

Hiveコネクタでは、偽装ユーザーはJDBCプロパティ  
    `
    hive.server2.proxy.user
    `
   を使用してターゲット システムに渡されます。

Sparkコネクタでは、偽装ユーザーはspark-submitコマンド パラメータ **proxy-user** を使用してターゲット システムに渡されます。

どちらの場合も、偽装ユーザーを **許可されているOSユーザー** に含めて、ターゲット システムでクエリーを実行できるようにしておく必要があります。HiveまたはSparkの偽装ユーザーは、次のいずれかのオプションを使用して定義できます。

|オプション|説明|
|--------|------------|
|開始システムのユーザー (既定)|Teradataシステムのユーザーが、偽装ユーザーとしてターゲット システムに渡されます。ユーザー名はすべて小文字に変換されます。|
|ユーザー マッピング|ユーザー マッピングにより、大文字・小文字の区別があるユーザー名を持つターゲット システム上の偽装ユーザーを、開始システム上の任意のユーザーに定義することができます。典型的なユース ケースとして、偽装ユーザー名が小文字に統一されていない場合が挙げられます。|

